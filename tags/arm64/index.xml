<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>arm64 on anitabyte</title>
    <link>/tags/arm64/</link>
    <description>Recent content in arm64 on anitabyte</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 22 Sep 2023 12:36:37 +0100</lastBuildDate><atom:link href="/tags/arm64/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Pi Any Means Necessary #2: Software availability</title>
      <link>/posts/pi_any_means_necessary_2/</link>
      <pubDate>Fri, 22 Sep 2023 12:36:37 +0100</pubDate>
      
      <guid>/posts/pi_any_means_necessary_2/</guid>
      <description>I&amp;rsquo;ve taken for granted in the past that if I&amp;rsquo;m on a Raspberry Pi, I&amp;rsquo;m going to have an easy time of getting software for ARM: it&amp;rsquo;s all-but the default platform for which ARM software is built, given the prevalence of the board in the marketplace. This isn&amp;rsquo;t - for now, at least - so true if you&amp;rsquo;re on a 64-bit OS. In spite of the Pi having a 64-bit processor since the Pi 3, the software ecosystem hasn&amp;rsquo;t quite caught up to that.</description>
      <content>&lt;p&gt;I&amp;rsquo;ve taken for granted in the past that if I&amp;rsquo;m on a Raspberry Pi, I&amp;rsquo;m going to have an easy time of getting software for ARM: it&amp;rsquo;s all-but the default platform for which ARM software is built, given the prevalence of the board in the marketplace. This isn&amp;rsquo;t - for now, at least - so true if you&amp;rsquo;re on a 64-bit OS. In spite of the Pi having a 64-bit processor since the Pi 3, the software ecosystem hasn&amp;rsquo;t quite caught up to that. This isn&amp;rsquo;t an issue for things distributed by Debian - all of that ends up in the core repositories and is only an &lt;code&gt;apt install&lt;/code&gt; away - but for things distributed in the likes of AppImages or Flatpaks, this poses more of a problem.&lt;/p&gt;
&lt;p&gt;I run a 3D printing shop online and use &lt;a href=&#34;https://github.com/prusa3d/PrusaSlicer/releases&#34;&gt;PrusaSlicer&lt;/a&gt; for preparing 3D models for printing. I was pleased to see that there is an ARMv7l AppImage available to download and decided to give it a go, having checked that I&amp;rsquo;d enabled &lt;code&gt;armhf&lt;/code&gt; as an architecture using &lt;code&gt;dpkg --add-architecture armhf&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This was not enough to get me to a point where the AppImage would run, with me being told that I was missing &lt;code&gt;ld-linux-armhf.so.3&lt;/code&gt;. This made sense, I thought, given that I&amp;rsquo;d only added the architecture&amp;rsquo;s to &lt;code&gt;apt&lt;/code&gt;&amp;rsquo;s configuration and not actually installed the packages. I went through some iteration of installing &lt;code&gt;armhf&lt;/code&gt; packages before I&amp;hellip; just gave up. Having installed &lt;code&gt;zlib1g:armhf&lt;/code&gt;, &lt;code&gt;libfuse2:armhf&lt;/code&gt;, &lt;code&gt;libstdc++6:armhf&lt;/code&gt;, &lt;code&gt;libbz2-1.0:armhf&lt;/code&gt;, &lt;code&gt;liblzma5:armhf&lt;/code&gt;, &lt;code&gt;libgl1:armhf&lt;/code&gt;, &lt;code&gt;libsm6:armhf&lt;/code&gt;, &lt;code&gt;libglib2.0-0:armhf&lt;/code&gt;, &lt;code&gt;libatk1.0-0:armhf&lt;/code&gt; and &lt;code&gt;libgdk-pixbuf-2.0-0:armhf&lt;/code&gt;, I realised that I&amp;rsquo;d probably end up installing an entire &lt;code&gt;armhf&lt;/code&gt; userland if I carried on this way.&lt;/p&gt;
&lt;p&gt;Rather than committing to the eternal iteration of package installs, I decided to bite the bullet and simply compile the application myself. Fortunately, PrusaSlicer&amp;rsquo;s &lt;a href=&#34;https://github.com/prusa3d/PrusaSlicer/blob/master/doc/How%20to%20build%20-%20Linux%20et%20al.md&#34;&gt;build instructions&lt;/a&gt; are good and complete, providing an accurate list of dependencies and being based on the assumption of a Debian-based system - making them easy enough to follow on Raspberry Pi OS. I&amp;rsquo;m lucky enough to be on an 8GB Pi 4, so didn&amp;rsquo;t run into any issues during the linking step: if I were on a 2GB or 4GB Pi, this would likely be a post about ARM cross-compilation. Fortunately we don&amp;rsquo;t have to involve ourselves with the Dark Arts here.&lt;/p&gt;
&lt;p&gt;The build itself took about an hour, resulting in a PrusaSlicer binary that happily ran. The performance of the 3D viewport in the application isn&amp;rsquo;t &lt;em&gt;great&lt;/em&gt;, but I didn&amp;rsquo;t expect otherwise. Slicing, however, &lt;em&gt;feels&lt;/em&gt; competitive with my Ryzen 9 7950X3D, which surprised me. I know that most slicing algorithms are limited by the performance of a single core and don&amp;rsquo;t multithread well, but not being frustrated with how long it took was a pleasant treat to receive.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;ve since found that out that &lt;a href=&#34;https://github.com/davidk/PrusaSlicer-ARM.AppImage/releases&#34;&gt;someone builds ARM64 PrusaSlicer AppImages and makes them available to download&lt;/a&gt;. Oh well.&lt;/p&gt;
&lt;p&gt;In my 3D printing workflow, I also use FreeCAD. This was available directly from the Raspberry Pi OS repositories and - again, surprising to me - was perfectly usable on the Pi. I&amp;rsquo;d expected frustrating amounts of latency with graphical updates and recalculations, but it&amp;rsquo;s very useable. This is of course a massively subjective measure of the performance of an application, but it&amp;rsquo;s ultimately the most important one: I feel like I&amp;rsquo;m capable of doing the work I need to do on the Pi without feeling like I&amp;rsquo;m limited by my hardware.&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
